/* Copyright (c) 2017-2020, EPFL/Blue Brain Project
 * Responsible Author: Grigori Chevtchenko <grigori.chevtchenko@epfl.ch>
 *
 * This file is part of EMSim <https://github.com/BlueBrain/EMSim>
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License version 3.0 as published
 * by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <algorithm>
#include <cstring>
#include <fstream>
#include <iostream>

#include <emSim/ComputeSamplePoints.h>
#include <emSim/SamplePoints.h>
#include <emSim/helpers.h>

namespace ems
{
SamplePoints::SamplePoints(uint32_t nTimeSteps,
                           const std::vector<glm::vec3>& positions)
    : _nSamplePoints(positions.size())
    , _nTimeSteps(nTimeSteps)
    , _flatPositions(alignedMalloc<float>(_nSamplePoints * 3u))
    , _values(alignedMalloc<float>(_nSamplePoints * _nTimeSteps))
{
    std::memset(_values.get(), 0.0f,
                _nSamplePoints * _nTimeSteps * sizeof(float));

    for (uint32_t i = 0; i < positions.size(); ++i)
    {
        _flatPositions[i * 3] = positions[i].x;
        _flatPositions[i * 3 + 1] = positions[i].y;
        _flatPositions[i * 3 + 2] = positions[i].z;
    }
}

void SamplePoints::computeNextFrame(const Events& events)
{
    ispc::ComputeSamplePoints_ispc(events.getFlatPositions(), events.getRadii(),
                                   events.getPowers(), events.getEventsCount(),
                                   _currentFrame, _flatPositions.get(),
                                   _values.get(), _nSamplePoints);
    std::cout << "\rINFO: Computing frames: " << _currentFrame + 1u << "/"
              << _nTimeSteps << "  -  "
              << 100.0f * (float)(_currentFrame + 1u) / (float)_nTimeSteps
              << "%." << std::flush;
    ++_currentFrame;
}

void SamplePoints::writeToFile(const glm::vec2& timeRange, const float dt,
                               const std::string& dataUnit,
                               const std::string& outputFile,
                               const std::string& blueconfig,
                               const std::string& report,
                               const std::string& target)
{
    std::ofstream output;
    output.open(outputFile + "_sample_points");

    output
        << "# File generated by EMSim tool:\n"
        << "# - BlueConfig: " << blueconfig << "\n"
        << "# - Target: " << target << "\n"
        << "# - Report: " << report << "\n"
        << "# - dt: " << dt << "\n"
        << "# - Time range: [" << timeRange.x << " " << timeRange.y << "]\n"
        << "# - Format: timestamp samplePoint1 samplePoint2 ... samplePointN\n"
        << "#" << std::endl;

    for (size_t i = 0; i < _nSamplePoints; ++i)
    {
        output << "# - SamplePoint_" << i
               << " position: " << _flatPositions[i * 3] << ","
               << _flatPositions[i * 3 + 1] << "," << _flatPositions[i * 3 + 2]
               << std::endl;
    }

    std::string voltUnit = dataUnit;
    std::replace(voltUnit.begin(), voltUnit.end(), 'A', 'V');
    output << "# - Units: " << voltUnit << std::endl;

    for (uint32_t i = 0; i < _nTimeSteps; ++i)
    {
        output << std::endl << timeRange.x + i * dt << " ";
        for (uint32_t j = 0; j < _nSamplePoints; ++j)
            output << _values[_nSamplePoints * i + j] << " ";
    }
}

const float* SamplePoints::getValues() const
{
    return _values.get();
}
}
